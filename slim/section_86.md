---
title: Lesson 3.15 - Intro to Doctrine - DataBase Abstraction Layer - DBAL
description: Slim notes.
order: 86
---

DBAL stands for "Database Abstraction Layer." It is a software library or component that provides an abstraction layer between your application code and one or more database management systems (DBMS). The primary purpose of a DBAL is to simplify database access and interaction for developers while also making it possible to work with multiple database systems without rewriting your application code.

Here are some key features and benefits of using a DBAL:

1. **Database Portability**: DBALs allow you to write database-agnostic code. You can write your application logic once and use the same code with different database systems (e.g., MySQL, PostgreSQL, SQLite, Oracle) by simply changing the configuration.

2. **SQL Abstraction**: DBALs often provide an object-oriented or query builder approach for generating SQL queries. This abstraction makes it easier to write complex queries and reduces the risk of SQL injection vulnerabilities.

3. **Connection Management**: DBALs handle database connection pooling, opening and closing connections as needed, and managing database transactions.

4. **Error Handling**: They provide consistent error handling and reporting, making it easier to detect and handle database-related errors in a uniform way.

5. **ORM Integration**: DBALs are often used as the foundation for Object-Relational Mapping (ORM) libraries like Doctrine ORM. These libraries provide higher-level abstractions for working with databases by mapping database tables to object-oriented models.

6. **Performance Optimization**: Some DBALs include query optimization features to improve the efficiency of your database queries.

7. **Schema Management**: Many DBALs provide tools for managing database schemas, including creating and modifying database tables, indexes, and constraints.

8. **Migrations**: Some DBALs include migration tools that allow you to version and manage changes to your database schema over time.

Popular DBALs in the PHP ecosystem include:

- **Doctrine DBAL**: Part of the Doctrine project, it is a widely used DBAL for PHP applications, particularly in conjunction with Doctrine ORM.

- **! PDO (PHP Data Objects)**: While PDO is not a full DBAL, it is a database-access abstraction layer built into PHP that provides a consistent interface to work with various databases. It's a data access layer.

- **Laravel Database Component**: Laravel, a popular PHP framework, includes a database component that acts as a DBAL and also provides an ORM called Eloquent.

- **Zend Db**: A component of the Zend Framework (now Laminas), it offers DBAL functionality for Zend-based applications.


Doctrine DBAL is a database abstraction layer for PHP that makes it easier to work with databases, including MySQL. Below is an example of how to use Doctrine DBAL to execute a query with dates as parameters using `bindValue`. In this example, we'll assume you have Doctrine DBAL installed and set up with a MySQL database.

```php
<?php
require_once 'vendor/autoload.php'; // Include the Doctrine DBAL autoloader

use Doctrine\DBAL\DriverManager;

// Database configuration
$dbParams = array(
    'dbname' => 'your_database_name',
    'user' => 'your_username',
    'password' => 'your_password',
    'host' => 'localhost',
    'driver' => 'pdo_mysql',
);

// Establish a database connection
$connection = DriverManager::getConnection($dbParams);

// Define your query
$query = "SELECT * FROM your_table WHERE created_at BETWEEN :startDate AND :endDate";

// Prepare and execute the query with parameters
$startDate = '2023-01-01';
$endDate = '2023-12-31';

$statement = $connection->prepare($query);
$statement->bindValue('startDate', $startDate, 'date');
$statement->bindValue('endDate', $endDate, 'date');
$statement->execute();

// Fetch the results
$results = $statement->fetchAll();

// Display the results
foreach ($results as $row) {
    echo "ID: " . $row['id'] . ", Name: " . $row['name'] . ", Created At: " . $row['created_at'] . "<br>";
}

```

In this example:

1. We first include the Doctrine DBAL autoloader, which is typically generated by Composer when you install Doctrine DBAL.

2. We define the database configuration in the `$dbParams` array, specifying the database name, username, password, host, and driver.

3. We establish a database connection using `DriverManager::getConnection`.

4. We define a SQL query with placeholders for the start date and end date.

5. We prepare the query with `prepare`, bind the values to the placeholders using `bindValue`, and specify the data type as `'date'`.

6. We execute the query with the bound parameters using `execute`.

7. We fetch the results using `fetchAll` and display them.

Make sure to replace `'your_database_name'`, `'your_username'`, `'your_password'`, and `'your_table'` with your actual database information and table name. Also, adjust the `$startDate` and `$endDate` variables to the desired date range for your query.

#### bindvalue and bindparam

`bindValue` and `bindParam` are two methods used for binding parameters in prepared statements in PHP when working with databases through PDO (PHP Data Objects). They are similar in functionality, but there is a key difference between them:

1. `bindValue`:

   - `bindValue` binds a value to a placeholder in the prepared statement.
   - It takes two arguments: the name or placeholder of the parameter and the value to bind.
   - The value is bound at the time of the `bindValue` call, and any changes to the variable after binding won't affect the parameter in the prepared statement.

   ```php
   $value = 42;
   $stmt->bindValue(':paramName', $value);
   $value = 100; // This change won't affect the bound parameter.
   ```

2. `bindParam`:

   - `bindParam` binds a reference to a variable to a placeholder in the prepared statement.
   - It takes three arguments: the name or placeholder of the parameter, the variable to bind, and an optional data type.
   - The binding is dynamic; changes to the variable's value are reflected in the prepared statement when executed.

   ```php
   $value = 42;
   $stmt->bindParam(':paramName', $value);
   $value = 100; // This change will affect the bound parameter.
   ```

In summary, `bindValue` binds a specific value to a parameter, while `bindParam` binds a reference to a variable, allowing changes to the variable to affect the parameter value in the prepared statement. The choice between them depends on whether you want the parameter's value to remain fixed (use `bindValue`) or be dynamic (use `bindParam`).

#### Arrays in Statement

You can achieve the same result using the Doctrine DBAL `DriverManager`. Here's an example using `DriverManager` to execute a query with the `IN` clause and bind an array of values as parameters:

```php
// Establish a database connection
$connection = DriverManager::getConnection($dbParams);

// Define an array of values for the IN clause
$paramArray = [1, 2, 3, 4];

// Construct the SQL query with a placeholder for the IN clause
$sql = "SELECT * FROM your_table WHERE column_name IN (:paramArray)";

// Prepare the SQL statement
$stmt = $connection->prepare($sql);

// Bind the array values to the placeholder
$stmt->bindValue('paramArray', $paramArray, \Doctrine\DBAL\Connection::PARAM_INT_ARRAY);

// Execute the query
$stmt->execute();

// Fetch the results
$results = $stmt->fetchAll();
    

```

#### Difference between fetchAll and fetchAllAssociative

`fetchAll` and `fetchAllAssociative` are two different methods used in Doctrine DBAL for fetching rows from a database result set. The main difference between them lies in how the fetched data is structured in the resulting array:

1. `fetchAll`:
   - The `fetchAll` method retrieves all rows from the result set as an array of arrays.
   - Each row is represented as an indexed (numeric) array, where column values can be accessed using numeric indices.
   - This method provides more flexibility if you want to access the data by column position.

   Example:
   ```php
   $result = $stmt->fetchAll();
   // $result is an array of arrays, e.g., [['column1' => 'value1', 'column2' => 'value2'], ...]
   ```

2. `fetchAllAssociative`:
   - The `fetchAllAssociative` method retrieves all rows from the result set as an array of associative arrays.
   - Each row is represented as an associative array, where column values can be accessed using column names as keys.
   - This method provides a more natural and convenient way to work with the data, as you can access columns by their names directly.

   Example:
   ```php
   $result = $stmt->fetchAllAssociative();
   // $result is an array of associative arrays, e.g., [['column1' => 'value1', 'column2' => 'value2'], ...]
   ```

In summary, `fetchAll` returns an array of indexed arrays, while `fetchAllAssociative` returns an array of associative arrays. You can choose the method that best fits your data retrieval needs and coding style. If you prefer accessing data by column names, `fetchAllAssociative` is often more convenient, whereas `fetchAll` may be more suitable when you need to work with data based on its position in the result set.

#### transactions

A transaction is a sequence of one or more SQL operations that are executed as a single unit of work. If all the operations within the transaction succeed, the changes are committed to the database; otherwise, if any operation fails, the entire transaction is rolled back, and no changes are made to the database. Transactions ensure data consistency and integrity. Here's an example of how to use transactions in PHP with PDO (PHP Data Objects):

```php
<?php
try {
    // Database configuration
    $dsn = "mysql:host=localhost;dbname=your_database_name";
    $username = "your_username";
    $password = "your_password";

    // Create a PDO instance and set it to use exceptions
    $pdo = new PDO($dsn, $username, $password);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    // Begin a transaction
    $pdo->beginTransaction();

    // SQL statements within the transaction
    $sql1 = "UPDATE your_table SET column1 = 'new_value1' WHERE id = 1";
    $sql2 = "UPDATE your_table SET column2 = 'new_value2' WHERE id = 2";

    // Execute the SQL statements
    $pdo->exec($sql1);
    $pdo->exec($sql2);

    // Commit the transaction if all operations were successful
    $pdo->commit();

    echo "Transaction committed successfully!";
} catch (PDOException $e) {
    // Rollback the transaction if any operation fails
    $pdo->rollBack();
    echo "Transaction failed: " . $e->getMessage();
}
?>
```

In this example:

1. We establish a connection to the database using PDO and set it to throw exceptions for error handling.

2. We begin a transaction using `$pdo->beginTransaction()`.

3. Inside the transaction, we perform one or more SQL operations (updates in this case) that we want to be part of the transaction.

4. If all SQL operations are successful, we commit the transaction using `$pdo->commit()`. This makes all the changes permanent in the database.

5. If any SQL operation within the transaction fails (e.g., due to a constraint violation or an error), we catch the exception, roll back the transaction using `$pdo->rollBack()`, and handle the error.

This ensures that either all changes are made successfully or none at all, maintaining the consistency and integrity of the data.

#### Query Builder

See [query builder](https://www.doctrine-project.org/projects/doctrine-orm/en/2.7/reference/query-builder.html)

Doctrine provides a Query Builder that allows you to build complex SQL queries using a more object-oriented approach. Here's an example of how to use the Doctrine Query Builder to perform a simple SELECT query:

```php
<?php
require_once 'vendor/autoload.php'; // Include the Doctrine DBAL autoloader

use Doctrine\DBAL\DriverManager;
use Doctrine\DBAL\Query\QueryBuilder;

// Database configuration
$dbParams = array(
    'dbname' => 'your_database_name',
    'user' => 'your_username',
    'password' => 'your_password',
    'host' => 'localhost',
    'driver' => 'pdo_mysql',
);

try {
    // Establish a database connection
    $connection = DriverManager::getConnection($dbParams);

    // Create a QueryBuilder instance
    $queryBuilder = new QueryBuilder($connection);

    // Build the SELECT query
    $queryBuilder
        ->select('*')
        ->from('your_table')
        ->where('column_name = :value')
        ->setParameter('value', 'desired_value');

    // Execute the query and fetch the results
    $stmt = $queryBuilder->execute();
    $results = $stmt->fetchAll();

    // Display the results
    foreach ($results as $row) {
        echo "ID: " . $row['id'] . ", Name: " . $row['name'] . "<br>";
    }
} catch (Exception $e) {
    echo "Error: " . $e->getMessage();
}
```

In this example:

1. We include the Doctrine DBAL autoloader.

2. We establish a database connection using `DriverManager::getConnection`.

3. We create a `QueryBuilder` instance, which allows us to build SQL queries in an object-oriented way.

4. We use the `select`, `from`, `where`, and `setParameter` methods to construct the SQL query. You can chain these methods together to build more complex queries.

5. We execute the query using `$queryBuilder->execute()`.

6. We fetch the results and display them as needed.

The `getSQL` method in Doctrine Query Builder is used to retrieve the SQL query string that has been built by the Query Builder instance. It's a helpful method when you want to inspect the generated SQL query for debugging purposes or if you need to use the query directly in certain situations. Here's how to use the `getSQL` method:

```php
// Create a QueryBuilder instance
$queryBuilder = new QueryBuilder($connection);

// Build the SELECT query
$queryBuilder
	->select('*')
	->from('your_table')
	->where('column_name = :value')
	->setParameter('value', 'desired_value');

// Get the generated SQL query
$sql = $queryBuilder->getSQL();

```

#### Create Schema Manager

Doctrine DBAL's `createSchemaManager` method allows you to interact with the database schema and retrieve information about the database, including the names of schemas (if your database system supports multiple schemas). Here's an example of how to use `createSchemaManager` to retrieve schema names:

```php
<?php
require_once 'vendor/autoload.php'; // Include the Doctrine DBAL autoloader

use Doctrine\DBAL\DriverManager;

// Database configuration
$dbParams = array(
    'dbname' => 'your_database_name',
    'user' => 'your_username',
    'password' => 'your_password',
    'host' => 'localhost',
    'driver' => 'pdo_mysql',
);

try {
    // Establish a database connection
    $connection = DriverManager::getConnection($dbParams);

    // Create a SchemaManager instance
    $schemaManager = $connection->getSchemaManager();

    // Get the names of all schemas (if supported by your database)
    $schemaNames = $schemaManager->listSchemaNames();

    // Display the schema names
    echo "Schema Names:<br>";
    foreach ($schemaNames as $schemaName) {
        echo $schemaName . "<br>";
    }
} catch (Exception $e) {
    echo "Error: " . $e->getMessage();
}
```

The Schema Manager in Doctrine DBAL provides various methods for managing and inspecting database schemas. Some of the main methods and their purposes are as follows:

1. `createDatabase($databaseName)`: Creates a new database with the specified name.

2. `dropDatabase($databaseName)`: Drops (deletes) a database with the specified name.

3. `createTable($table)`: Creates a new table based on the provided `Table` object.

4. `alterTable($tableName, Closure $closure)`: Alters an existing table using a closure that defines the changes.

5. `dropTable($tableName)`: Drops (deletes) a table with the specified name.

6. `tablesExist(array $tableNames)`: Checks if the specified tables exist in the database.

7. `listDatabases()`: Lists all available databases on the connected server.

8. `listTableColumns($tableName)`: Lists all columns of a specific table.

9. `listTableIndexes($tableName)`: Lists all indexes (including primary and unique keys) of a specific table.

10. `listTableDetails($tableName)`: Retrieves detailed information about a table, including columns, indexes, and foreign keys.

11. `listTables()`: Lists all tables in the database.

12. `listViews()`: Lists all views in the database.

13. `listTableForeignKeys($tableName)`: Lists all foreign keys of a specific table.

14. `listTableNames()`: Lists the names of all tables in the database.

15. `listSchemaNames()`: Lists the names of all schemas (if supported by the database system).

16. `createSchema($schemaName)`: Creates a new schema (if supported by the database system).

17. `dropSchema($schemaName)`: Drops (deletes) a schema (if supported by the database system).


